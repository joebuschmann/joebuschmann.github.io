---
layout: post
title: Text Parsing with F#
date: '2012-01-15 21:02:30'
tags:
- net
- f
- text-parsing
---

<p>IΓÇÖve always had a fear of parsing text.&nbsp; Strange since itΓÇÖs a basic programmerΓÇÖs task.&nbsp; IΓÇÖve always found it to be tedious and boring, and the resulting code is a jumbled mess of indexes and string parsing methods.&nbsp; I avoid it every chance I get.</p> <p>And thereΓÇÖs regex.&nbsp; The syntax is cryptic and difficult to remember.&nbsp; ItΓÇÖs another thing I should know well, but, again, I avoid it.</p> <p>Recently I decided to come to grips with this weakness and parse a text file containing information about TCP sockets in a TIME_WAIT status.&nbsp; It was generated by a co-worker investigating network performance.&nbsp; He wanted to get a list of IP addresses along with the amount of time they spent with a status of TIME_WAIT.&nbsp; Then he could pull it into Excel to visualize the data.</p> <p>IΓÇÖve been told that functional languages are great for parsing text, so I decided to use F#.&nbsp; While doing some research, I came to a sudden realization.&nbsp; The reason why it has always been difficult for me was I had been taking the wrong approach.&nbsp; I was intermingling the parsing code with the business logic code.&nbsp; My approach was along the lines of:&nbsp; parse a line, pull some string values from previous lines from state, run some logic for the current line, store the string values in state, and move to the next line.&nbsp; Included in the code were lots of index values into the text, helper methods, and conversions to data types like dates, integers, etc.&nbsp; All that mixed in with the business logic.&nbsp; No wonder I hated it.</p> <p>The correct approach (or at least a better one) is to convert the textual representation of the data into data structures before running any business logic.&nbsp; There should be a clear separation between the two.&nbsp; With this step, the logic becomes easier.&nbsp; There are no indexes or type conversions.&nbsp; All thatΓÇÖs been done, and the business logic is focused and concise.</p> <h3>The Data Structures</h3> <p>Before I could continue, I needed to understand the data represented in the file from my co-worker and map them to data structures.&nbsp; A portion of the file is below.</p><pre>Time : 2011-11-09_08:36:19
Time : 2011-11-09_08:36:24
Time : 2011-11-09_08:36:29
Time : 2011-11-09_08:36:34
Time : 2011-11-09_08:36:40
Time : 2011-11-09_08:36:45
Time : 2011-11-09_08:36:50
Time : 2011-11-09_08:36:56
Time : 2011-11-09_08:37:01
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1804&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1812&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
Time :&nbsp; 2011-11-09_08:37:06
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1804&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1809&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1812&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1813&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1818&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1819&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1829&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1831&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1834&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</pre>
<p>Each line was written in intervals of about 5 seconds.&nbsp; There seemed to be two types of information recorded, a timestamp and an IP address of a socket with a status of TIME_WAIT, and each needed its own data structure.&nbsp; The IP address lines were consistent in their format; however, the timestamps were not.&nbsp; Sometimes there was a line break between the ΓÇ£Time :ΓÇ¥ label and the value and other times they were on the same line.&nbsp; The table below breaks down each type of line format and the action to take.</p>
<table border="0" cellspacing="0" cellpadding="2" width="587">
<tbody>
<tr>
<td valign="top" width="429">
<h5>Format</h5></td>
<td valign="top" width="156">
<h5>Action</h5></td></tr>
<tr>
<td valign="top" width="429">Time : 2011-11-09_08:37:01</td>
<td valign="top" width="156">Create a data structure representation</td></tr>
<tr>
<td valign="top" width="429">Time :</td>
<td valign="top" width="156">Ignore</td></tr>
<tr>
<td valign="top" width="429">2011-11-09_08:37:11</td>
<td valign="top" width="156">Create a data structure representation</td></tr>
<tr>
<td valign="top" width="429">TCP&nbsp;&nbsp;&nbsp; 10.28.65.14:1834&nbsp;&nbsp;&nbsp; 10.28.65.15:808&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp;&nbsp; 0</td>
<td valign="top" width="156">Create a data structure representation</td></tr></tbody></table>
<p>&nbsp;</p>
<p>To represent the data, I used a discriminated union with two discriminators that store the timestamp and IP address.&nbsp; For the lines with the IP addresses, there are two addresses, and only the first one is useful because it is the one in a TIME_WAIT state.&nbsp; The remaining information is superfluous and can be discarded.</p><pre class="code"><span style="color: blue">type </span>LineRecord =
| TimeRecord <span style="color: blue">of </span>DateTime
| TimeWaitRecord <span style="color: blue">of </span>int * int * int * int * int</pre>
<h3>Active Patterns</h3>
<p>To parse each line into a LineRecord, I used an F# feature called <a href="http://msdn.microsoft.com/en-us/library/dd233248.aspx" target="_blank">active patterns</a> which allowed me to set up pattern matching expressions for text values just as I would for a discriminated union.&nbsp; I created four active pattern definitions.&nbsp; The first two take a string value and attempt to return a date or an IP address.&nbsp; The next two take a line of text from the file and return a LineRecord discriminator value.&nbsp; Once these were in place, writing a function to convert the text file into a list of LineRecord values became trivial.</p><pre class="code"><span style="color: green">// Attempt to convert a string value into a date.
</span><span style="color: blue">let </span>(|Date|_|) (input:string) =
  <span style="color: blue">let </span>(success, date) = DateTime.TryParse(input)
  <span style="color: blue">if </span>(success) <span style="color: blue">then </span>Some(date)
  <span style="color: blue">else </span>None

<span style="color: green">// Attempt to convert a string value into an IP address
// represented by a tuple with four or five integers with
// the port being optional.
</span><span style="color: blue">let </span>(|IP|_|) (input:string) =
  <span style="color: blue">let </span>delimChars = [|<span style="color: maroon">'.'</span>; <span style="color: maroon">':'</span>|]
  <span style="color: blue">let </span>arr = input.Split(delimChars)
  <span style="color: blue">match </span>arr.Length <span style="color: blue">with
  </span>| 4 <span style="color: blue">-&gt; </span>Some((int(arr.[0]), int(arr.[1]), int(arr.[2]), int(arr.[3]), 0))
  | 5 <span style="color: blue">-&gt; </span>Some((int(arr.[0]), int(arr.[1]), int(arr.[2]), int(arr.[3]),
               int(arr.[4])))
  | _ <span style="color: blue">-&gt; </span>None

<span style="color: green">// Attempt to convert a time record.
</span><span style="color: blue">let </span>(|TimeEntry|_|) (line:string) =
  <span style="color: blue">let </span>line = line.Trim().Replace(<span style="color: maroon">"Time : "</span>, <span style="color: maroon">""</span>).Replace(<span style="color: maroon">'_'</span>, <span style="color: maroon">' '</span>)
  <span style="color: blue">match </span>line <span style="color: blue">with
  </span>| Date dateTime <span style="color: blue">-&gt; </span>Some(TimeRecord(dateTime))
  | _ <span style="color: blue">-&gt; </span>None

<span style="color: green">// Attempt to convert a TIME_WAIT record.
</span><span style="color: blue">let </span>(|TimeWaitEntry|_|) (line:string) =
  <span style="color: blue">let </span>line = line.Replace(<span style="color: maroon">"TCP"</span>, <span style="color: maroon">""</span>).Trim()
  <span style="color: blue">let </span>index = line.IndexOf(<span style="color: maroon">' '</span>)

  <span style="color: blue">match </span>index <span style="color: blue">with
  </span>| -1 <span style="color: blue">-&gt; </span>None
  | index <span style="color: blue">-&gt;
    let </span>line = line.Substring(0, index)
    <span style="color: blue">match </span>line <span style="color: blue">with
    </span>| IP (ip) <span style="color: blue">-&gt; </span>Some(TimeWaitRecord ip)
    | _ <span style="color: blue">-&gt; </span>None

<span style="color: green">// Parses lines from the file into a list of LineRecords.
</span><span style="color: blue">let </span>parseFile lines =
  <span style="color: blue">let </span>lines = lines |&gt; List.rev
  <span style="color: blue">let rec </span>parseFileUtil lines acc =
    <span style="color: blue">match </span>lines <span style="color: blue">with
    </span>| hd :: tl <span style="color: blue">-&gt;
      let </span>acc = <span style="color: blue">match </span>hd <span style="color: blue">with
                </span>| TimeEntry timeRecord <span style="color: blue">-&gt; </span>timeRecord :: acc
                | TimeWaitEntry timeWaitRecord <span style="color: blue">-&gt; </span>timeWaitRecord :: acc
                | _ <span style="color: blue">-&gt; </span>acc
      parseFileUtil tl acc
    | [] <span style="color: blue">-&gt; </span>acc
  parseFileUtil lines []</pre>
<h3>Running the Business Logic</h3>
<p>Now that the contents of the file were represented neatly as a data structure, it was much easier to manipulate the data.&nbsp; For example, I could get a list of times and the number of IP addresses in a TIME_WAIT state and save this list to a CSV file.</p><pre class="code"><span style="color: blue">open </span>System
<span style="color: blue">open </span>System.Collections.Generic
<span style="color: blue">open </span>System.IO
<span style="color: blue">open </span>DataStructures

<span style="color: blue">let </span>lines = File.ReadAllLines(<span style="color: maroon">"out_time0.txt"</span>) |&gt; Array.toList
<span style="color: blue">let </span>items = parseFile lines

<span style="color: green">// Find the times of each TIME_WAIT record and return a tuple
// with the time and IP address.  Since the time was written
// to the file once for a set of addresses, it has to be
// passed into the util function as state.  The accumulator
// parameter exists to enable tail call optimization.
</span><span style="color: blue">let </span>getTimeWaitTimes items =
  <span style="color: blue">let rec </span>util items (currentTime:DateTime) acc =
      <span style="color: blue">match </span>items <span style="color: blue">with
      </span>| hd :: tl <span style="color: blue">-&gt;
        let </span>currentTime = <span style="color: blue">match </span>hd <span style="color: blue">with
                          </span>| TimeRecord newTime <span style="color: blue">-&gt; </span>newTime
                          | _ <span style="color: blue">-&gt; </span>currentTime

        <span style="color: blue">let </span>acc = <span style="color: blue">match </span>hd <span style="color: blue">with
                  </span>| TimeWaitRecord (val1, val2, val3, val4, val5) <span style="color: blue">-&gt;
                    </span>(currentTime, (val1, val2, val3, val4, val5)) :: acc
                  | _ <span style="color: blue">-&gt; </span>acc

        <span style="color: green">//printfn "Current Time %s" (currentTime.ToString())
        </span>util tl currentTime acc
      | [] <span style="color: blue">-&gt; </span>acc
  util items DateTime.MinValue []

<span style="color: blue">let </span>timeWaits = getTimeWaitTimes items

<span style="color: green">// Create a map of the number of IP addresses in a
// TIME_WAIT state at a give time.  The time is the key.
</span><span style="color: blue">let </span>counts = timeWaits |&gt; List.fold (<span style="color: blue">fun </span>(state:Map&lt;_,_&gt;) (time, _) <span style="color: blue">-&gt;
                                      if </span>(state.ContainsKey(time)) <span style="color: blue">then
                                        </span>state |&gt; Map.map
                                                (<span style="color: blue">fun </span>k v <span style="color: blue">-&gt;
                                                  if </span>k = time <span style="color: blue">then
                                                    </span>v + 1
                                                  <span style="color: blue">else </span>v)
                                      <span style="color: blue">else
                                        </span>state.Add(time, 1)
                                    ) (Map.empty)

<span style="color: green">// Write the results to a CSV file.
</span><span style="color: blue">let </span>file = File.CreateText(<span style="color: maroon">"results.csv"</span>)
file.WriteLine(<span style="color: maroon">"Time,Count"</span>)

counts |&gt; Map.iter (<span style="color: blue">fun </span>k v <span style="color: blue">-&gt; </span>file.WriteLine(<span style="color: maroon">"{0},{1}"</span>, k, v) )

file.Flush()

ignore(Console.ReadLine())</pre>
<p>You can find the full source code including unit tests <a href="https://github.com/joebuschmann/FSharpTextParsing" target="_blank">on GitHub</a>.</p>
<p>This was a simple example, but it demonstrates the power of converting the textual data to an internal representation.&nbsp; With the parsing done, the business logic comes together much easier.&nbsp; Also, the active pattern language feature in F# makes the textual analysis simpler.</p>
<p>Now, if I could only master regex.</p>