<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>task on Joe Buschmann</title>
    <link>https://joebuschmann.com/tags/task/</link>
    <description>Recent content in task on Joe Buschmann</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Joe Buschmann 2020</copyright>
    <lastBuildDate>Mon, 15 Aug 2016 13:28:32 +0000</lastBuildDate>
    
	<atom:link href="https://joebuschmann.com/tags/task/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TaskCompletionSource - Bridging the Gap Between Old and New</title>
      <link>https://joebuschmann.com/posts/2016-08-15-taskcompletionsource-bridging-the-gap-between-old-and-new/</link>
      <pubDate>Mon, 15 Aug 2016 13:28:32 +0000</pubDate>
      
      <guid>https://joebuschmann.com/posts/2016-08-15-taskcompletionsource-bridging-the-gap-between-old-and-new/</guid>
      <description>In the latest versions of the .NET Framework, asynchronous work is represented by the Task class. A task is similar to a future or promise in other languages. You can create one in many ways the most common being Task.Run(). The result of a task is exposed by the Task.Result property. If the work is complete, then the property immediately returns a value; otherwise, it blocks until the operation is finished.</description>
    </item>
    
    <item>
      <title>A Short and Easy Introduction to .NET&#39;s Task Class</title>
      <link>https://joebuschmann.com/posts/2015-12-09-a-short-and-easy-introduction-to-dotnet-task-class/</link>
      <pubDate>Wed, 09 Dec 2015 22:09:29 +0000</pubDate>
      
      <guid>https://joebuschmann.com/posts/2015-12-09-a-short-and-easy-introduction-to-dotnet-task-class/</guid>
      <description>Task.Run You can use Task.Run to schedule a delegate to run on the thread pool. The method returns a new task, and if the work is complete, the result will be available via Task.Result. If not, Task.Result will block until it is complete.
Task.ContinueWith You&#39;ll want to avoid accessing the Task.Result property because it will block until the result is ready. In the previous example, the UI will hang for about 2000 milliseconds before updating the label with the result.</description>
    </item>
    
  </channel>
</rss>